try:
    import logging
    import os
    from datetime import datetime
    import math

    from controller import Robot as WebotsRobot  # type: ignore
    from helpers import delay
    from debugging import ALL_SYSTEMS, DebugInfo, HttpHandler, System
    from devices import GPS, IMU, ColorSensor, Communicator, Lidar, Motor, DistanceSensor, Camera
    from dfs import dfs
    from maze import Maze
    from robot import Robot
    from types_and_constants import DEBUG, NGROK_URL, ON_DOCKER, Coordinate, MAX_SPEED, SpecialTileType
    #import matplotlib.pyplot as plt
    from recognize_wall_token import reconhece_lado

    radius = (0.071/2) + 0.005

    x_total = []
    y_total = []
    contador_imagem = 0
    contador_imagem1 = 0
    # Variáveis derivada e Integral
    integral = 0
    derivada = 0
    last_error = 0
    erro = 0
    erro2 = 0
    last_error2 = 0
    Pot0 = MAX_SPEED - 3.5
    condicao_sala4 = False
    desejada = 0.045
    IMU_THRESHOLD = IMU_THRESHOLD=math.pi/6

    if ON_DOCKER:
        import requests  # type: ignore

    def radians(degrees: int)->float:
                return degrees*(math.pi/180)
    
    def conferir_circulo(centro: list, ponto: list, raio: float) -> bool:
        """
        confere se o ponto está dentro da circunferencia de centro e raio especificado
        """
        if (math.pow(ponto[0] - centro[0], 2) + math.pow(ponto[1] - centro[1], 2)) < (math.pow(raio,2)) : return True
        else : return False
    

    def get_distance(angle) -> float:
                
                rangeImage = lidar._get_range_image_() # Step 4: Retrieve the range image
                n = (angle*512)//360
                print()
                dist = 0
                count = 0
                for i in range(4):
                    if rangeImage[n+ i*512] != float('inf') : 
                        dist += rangeImage[n+ i*512]
                        count +=1
                if count != 0:
                    dist = dist/count
                else : dist = 0
                return dist

    def get_posicao_atual():
                ''' 
                    posicao_atual = gps.getValues()
                    posicaoX_atual = posicao_atual[0]
                    posicaoY_atual = posicao_atual[2]

                    return [posicaoX_atual, posicaoY_atual]
                '''
                P = gps.get_position()
                x = P.__getattribute__('x')
                y = P.__getattribute__('y')
                coordinates = [x,y]
                #print(f"coordinates é : {coordinates}")
                return coordinates

    

    # Initialize logger
    try:
        log_dir = os.path.dirname(os.getenv("LOG_PATH", ""))
        os.makedirs(log_dir, exist_ok=True)
        logging.basicConfig(
            level=logging.DEBUG,
            format="%(levelname)s %(message)s",
            filename=os.getenv("LOG_PATH"),
        )
        logger = logging.getLogger("Robo LARC v1")
        logger.info(f"Criado log com sucesso em: {os.getenv('LOG_PATH')}")
        if ON_DOCKER:
            print(f"Url do ngrok recuperada: {NGROK_URL}")

            requests.post(f"{NGROK_URL}/start_simulation")

            http_handler = HttpHandler(f"{NGROK_URL}/send")
            http_handler.setLevel(logging.DEBUG)
            formatter = logging.Formatter("%(levelname)s %(message)s")
            http_handler.setFormatter(formatter)
            logger.addHandler(http_handler)

            print("Adicionado handler com ngrok")

    except Exception:
        if DEBUG:
            logging.error("Erro ao inicializar o logger", exc_info=True)
            raise


    def main() -> None:
        # Initialize DebugInfo instance
        if DEBUG:
            logger.info(f"Começando nova execução: {datetime.now()}")

        try:
            # debug_info = DebugInfo(
            #     systems_to_debug=[
            #         e for e in ALL_SYSTEMS if str(e) not in [str(System.lidar_measures)]
            #     ],
            #     systems_to_ignore=[System.lidar_measures],
            # )
            want = [
                # System.dfs_state,
                # System.dfs_decision,
                # System.dfs_verification,
                # System.maze_visited,
                #System.wall_token_recognition,
                #System.wall_token_classification,
                System.unknown_error,
                #System.maze_snapshot,
            ]
            global debug_info
            debug_info = DebugInfo(
                logger,
                systems_to_debug=want,
                systems_to_ignore=[
                    e for e in ALL_SYSTEMS if str(e) not in [str(w) for w in want]
                ],
            )
        except Exception:
            if DEBUG:
                logger.error("Erro ao inicializar o debug info", exc_info=True)
                raise

        # Initialize robot and devices
        try:

            webots_robot = WebotsRobot()
            webots_robot.step(int(os.getenv("TIME_STEP", 32)))
            
            global motor, lidar, gps, imu, color_sensor, communicator, distancesensor
            gps = GPS(webots_robot, debug_info)
            motor = Motor(webots_robot, debug_info)
            lidar = Lidar(webots_robot, debug_info)
            imu = IMU(webots_robot, debug_info)
            color_sensor = ColorSensor(webots_robot, debug_info)
            communicator = Communicator(webots_robot, debug_info)
            distance_sensor = DistanceSensor(webots_robot, debug_info)
            camera = Camera(webots_robot, debug_info)

        except Exception:
            if DEBUG:
                debug_info.send(
                    "Erro durante inicialização dos devices", System.initialization, "error"
                )
                raise

        try:
            global robot
            robot = Robot(
                webots_robot, motor, lidar, gps, imu, color_sensor, communicator, camera, distance_sensor, debug_info
            )
            robot.step()
        except Exception:
            if DEBUG:
                debug_info.send(
                    "Erro durante inicialização do robô", System.initialization, "error"
                )
                raise

        # Solve map
        try:

            def ver_obstaculo():
                frente = distance_sensor.pegar_distancia(distance_sensor._front)
                tras_esquerda = distance_sensor.pegar_distancia(distance_sensor._backleft)
                tras_direita = distance_sensor.pegar_distancia(distance_sensor._backright)
                distancia = 0.037
                condicao = False
                onde = []
                print(tras_direita)
                if frente<distancia:
                    condicao = True
                    onde.append('frente')
                if tras_esquerda<distancia:
                    condicao = True
                    onde.append('tras_esquerda')
                if tras_direita<distancia:
                    condicao = True
                    onde.append('tras_direita')
                return condicao, onde
                    




            
            while robot.step() != -1:
                
                #x, y = get_mapa()
                #seguir_parede_sala4()
                condicao, onde = ver_obstaculo()
                print(f"Tem obstáculo : {print(condicao)} ; onde : {print(onde)}")
                
                #sala4()
                
                #fig, ax = plt.subplots()
                #ax.yaxis.set_inverted(True)
                #ax.scatter(x_total,y_total)
                #fig.savefig(f"C:\\Users\\goten\\Desktop\\LARCv1\\LARC_Simulation_Codes\\images\\mapa_total.png")
                #plt.close(fig)
                delay(webots_robot, debug_info, 100)

        except Exception:
            if DEBUG:
                debug_info.send(
                    "Erro inesperado enquanto resolvia o mapa",
                    System.unknown_error,
                    "critical",
                )
                raise


    try:
        main()
    except Exception:
        pass
    if ON_DOCKER:
        http_handler.send_queue_data()
except Exception as err:
    from controller import Robot as WebotsRobot  # type: ignore

    webots_robot = WebotsRobot()
    webots_robot.step(int(os.getenv("TIME_STEP", 32)))

    if (os.getenv("ON_DOCKER", "") + " ").upper()[0] in ["T", "1"]:
        import logging

        import requests  # type: ignore

        class HttpHandler(logging.Handler):  # type: ignore
            def __init__(
                self,
                url: str,
            ):
                self.url = url
                logging.Handler.__init__(self=self)

            def emit(self, record: logging.LogRecord) -> None:
                requests.post(
                    self.url, json={"new_entries": f"{self.format(record)}\n"}
                )

        logging.basicConfig()
        logger = logging.getLogger("Robo LARC v1")

        NGROK_URL = ""
        with open("./ngrok.txt", "r") as file:
            NGROK_URL = file.readlines()[0]
        print(f"Url do ngrok recuperada: {NGROK_URL}")

        try:
            resp = requests.post(f"{NGROK_URL}/start_simulation")
            print(resp.text)
        except Exception as e:
            print(f"Erro: {e}")

        http_handler = HttpHandler(f"{NGROK_URL}/send")
        http_handler.setLevel(logging.DEBUG)
        formatter = logging.Formatter("%(levelname)s %(message)s")
        http_handler.setFormatter(formatter)
        logger.addHandler(http_handler)

        logger.critical("erro geral", exc_info=True)
    print(err)
